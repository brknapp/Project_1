---
title: "Project 1"
---

```{r render, echo = FALSE, eval = FALSE}
rmarkdown::render("README.Rmd",
                  output_format = "github_document",
                  output_options = list(
                      toc = TRUE,
                      html_preview=FALSE) 
)
```

# Lets Get Started: OMDb API Key

In order to access the OMDb API, you need to get a free [api key](http://www.omdbapi.com/apikey.aspx). In the rest of this document, "mykey" refers to your OMDb API key.

You should also "turn on" these packages by running the code below. If you don't have them installed yet, run `install.packages()` with the package in quotes. For example, to install `tidyverse`, you would run `install.packages("tidyverse")`.

```{r 7_03_6_22_2022,message=FALSE,warning=FALSE}
library(httr) #this package will help use use the URL we built to get information from the OMDb API
library(jsonlite) #this package will help us convert the data we get from the OMDb API to a more usable format
library(tidyverse) #this package will help us work with our nicely formatted data.
library(lubridate) #this package will help us create dates 
library(ggplot2) #this package will help us make graphs
```

In order to get information from the OMDb API, we have to build a URL with our search criteria. It's similar to doing a Google search. There are two ways to build a URL: "By ID or Title" or "By Search".

# Build URL for One Movie Title

Let's say you have a movie title in mind, like Star Wars (1977). Here's a function you can use to get data from the OMDb API about Star Wars (1977):

Note: the parameter “type” has three options: movie, series, and episode. If “type” is not specified, it will give everything (including movies, series, and episodes). I’m making the default for “type” be “movie”, but you can change this if you want.

```{r search_by_title_Star_Wars}
search_by_title <- function(mykey,title,type="movie"){
  base_url <- paste0("http://www.omdbapi.com/?apikey=",mykey)
  info_url <- paste0("&t=",title,"&type=",type) 
  full_url <- paste0(base_url, info_url)
  full_url <- gsub(full_url, pattern = " ", replacement = "%20")
  
  movie_api_call <- GET(full_url)
  movie_api_call_char <- rawToChar(movie_api_call$content)
  movie_JSON <- jsonlite::fromJSON(movie_api_call_char, flatten = TRUE) 
  movie_JSON <- as.data.frame(movie_JSON)
  tibble_movie_JSON <- as_tibble(movie_JSON)
  return(tibble_movie_JSON)
}
```

You should run the function like this:

```{r 3_50_6_21_2022,eval=FALSE}
search_by_title("mykey","star_wars",type="movie")
```


You should get a tibble that looks like this:

```{r example_search_by_title_Star_Wars, eval=TRUE, echo=FALSE}
search_by_title("5c7f9206","star_wars",type="movie")
```

# Build URL for One Movie Title and One Date

If you don't specify a date, the OMDb API will give the first result. So, since Star Wars (1977) was the first Star Wars movie ever made, it gives Star Wars (1977) as the result. But, what if you wanted a different Star Wars movie like Star Wars: Episode VII - The Force Awakens (2015)? You can use this funciton:

```{r 7_11_6_22_2022}
search_by_title_and_date <- function(mykey,title,type="movie",date){
  base_url <- paste0("http://www.omdbapi.com/?apikey=",mykey)
  info_url <- paste0("&t=",title,"&type=",type,"&y=",date) 
  full_url <- paste0(base_url, info_url)
  full_url <- gsub(full_url, pattern = " ", replacement = "%20")
  
  movie_api_call <- GET(full_url)
  movie_api_call_char <- rawToChar(movie_api_call$content)
  movie_JSON <- jsonlite::fromJSON(movie_api_call_char, flatten = TRUE) 
  movie_JSON <- as.data.frame(movie_JSON)
  tibble_movie_JSON <- as_tibble(movie_JSON)
  return(tibble_movie_JSON)
}
```


You should run the function like this:

```{r 8_00_6_22_2022,eval=FALSE}
search_by_title_and_date("mykey","star_wars",type="movie",date=2015)
```

Get a tibble like this:

```{r 7_13_6_22_2022,eval=TRUE,echo=FALSE}
search_by_title_and_date("5c7f9206","star_wars",type="movie",date=2015)
```

# Build URL for One IMDb ID

Lets say you have a valid IMDb ID. You can find an IMDb ID by searching for a title on the [IMDb website](www.imdb.com). After you find a movie you like, the IMDb ID will be in the URL. For example, the URL for the IMDb page for Star Wars: Episode V - The Empire Strikes Back (1980) is https://www.imdb.com/title/tt0080684/?ref_=nv_sr_srsg_0. Therefore, its IMDb ID is tt0080684.

Here's a function you can use if you have a valid IMDb ID:

```{r search_by_IMDb_ID_Star_Wars, message=FALSE,warning=FALSE}
search_by_IMDb_ID <- function(mykey,IMDb_ID,type="movie"){
  base_url <- paste0("http://www.omdbapi.com/?apikey=",mykey)
  info_url <- paste0("&i=",IMDb_ID,"&type=",type) 
  full_url <- paste0(base_url, info_url)
  full_url <- gsub(full_url, pattern = " ", replacement = "%20")
  
  movie_api_call <- GET(full_url)
  movie_api_call_char <- rawToChar(movie_api_call$content)
  movie_JSON <- jsonlite::fromJSON(movie_api_call_char, flatten = TRUE) 
  movie_JSON <- as.data.frame(movie_JSON)
  tibble_movie_JSON <- as_tibble(movie_JSON)
  return(tibble_movie_JSON)
}
```

You should run the function like this:

```{r 3_54_6_21_2022,eval=FALSE}
search_by_IMDb_ID("mykey","tt0080684",type="movie")
```

You should get a tibble that looks like this:

```{r example_search_by_IMDb_ID_Star_Wars, eval=TRUE, echo=FALSE}
search_by_IMDb_ID("5c7f9206","tt0080684",type="movie")
```

# Build URL to Search for Movies in a Series

Let's say you wanted to get all of the titles for all of the Star Wars movies. You would then need to build your URL "By Search" instead. Here's a function you can use if you wanted to search for multiple movie titles:

```{r by_search, message=FALSE,warning=FALSE}
by_search_series <- function(mykey,title,type="movie"){
  base_url <- paste0("http://www.omdbapi.com/?apikey=",mykey)
  info_url <- paste0("&s=",title,"&type=",type) 
  full_url <- paste0(base_url, info_url)
  full_url <- gsub(full_url, pattern = " ", replacement = "%20")
  
  movie_api_call <- GET(full_url)
  movie_api_call_char <- rawToChar(movie_api_call$content)
  movie_JSON <- jsonlite::fromJSON(movie_api_call_char, flatten = TRUE) 
  movie_JSON <- as.data.frame(movie_JSON)
  tibble_movie_JSON <- as_tibble(movie_JSON)
  return(tibble_movie_JSON)
}
```

You should run the function like this:

```{r 3_57_6_21_2022,eval=FALSE}
by_search_series("mykey","star_wars",type="movie")
```

You should get a tibble that looks like this:

```{r example_by_search, eval=TRUE, echo=FALSE}
by_search_series("5c7f9206","star_wars",type="movie")
```

# Build URL to Search for One or More Titles or Series

Now, what if you want to get all of the data for all of the Star Wars movies and all of the Indiana Jones movies. The function below can handle a list of several titles or one title.

```{r test_3_35_6_20_2022}
mat=NULL
by_search_one_or_more_titles <- function(mykey,title,type="movie"){
 if(length(title)<=1){ 
  base_url <- paste0("http://www.omdbapi.com/?apikey=",mykey)
    info_url <- paste0("&s=",title,"&type=",type) 
    full_url <- paste0(base_url, info_url)
    full_url <- gsub(full_url, pattern = " ", replacement = "%20")
    
    movie_api_call <- GET(full_url)
    movie_api_call_char <- rawToChar(movie_api_call$content)
    movie_JSON <- jsonlite::fromJSON(movie_api_call_char, flatten = TRUE) 
    movie_JSON <- as.data.frame(movie_JSON)
    movie_JSON <- as_tibble(movie_JSON)
    return(movie_JSON)
 }
  if(length(title)>1){
  for(i in title){
  base_url <- paste0("http://www.omdbapi.com/?apikey=",mykey)
  info_url <- paste0("&s=",i,"&type=",type) 
  full_url <- paste0(base_url, info_url)
  full_url <- gsub(full_url, pattern = " ", replacement = "%20")
  
  movie_api_call <- GET(full_url)
  movie_api_call_char <- rawToChar(movie_api_call$content)
  movie_JSON <- jsonlite::fromJSON(movie_api_call_char, flatten = TRUE) 
  movie_JSON <- as.data.frame(movie_JSON)
  mat=rbind(mat,movie_JSON)
  mat=as_tibble(mat)
  }
    }
  return(mat)
}
```

You should run the function like this:

```{r ex_test_3_50_6_20_2022,eval=FALSE}
by_search_one_or_more_titles("mykey",c("star_wars","indiana_jones"),type="movie")
```

You would get the tibble below: 

```{r ex_test_3_35_6_20_2022,eval=TRUE,echo=FALSE}
by_search_one_or_more_titles("5c7f9206",c("star_wars","indiana_jones"),type="movie")
```

If you wanted to search for one title or series, like Indiana Jones, you would run the function like this:

```{r ex_test_3_54_6_20_2022,eval=FALSE}
by_search_one_or_more_titles("mykey","indiana_jones",type="movie")
```

You would get this tibble:

```{r 9_04_6_22_2022,eval=TRUE,echo=FALSE}
by_search_one_or_more_titles("5c7f9206","indiana_jones",type="movie")
```

# Get the Data for One Series

That's great! Now, lets get the data for all of the Star Wars movies:

```{r get_data}
mat=NULL
get_data_series <- function(mykey,title){
  temp_table <- by_search_series(mykey,title,type="movie")
  list_of_titles <- unique(temp_table$Search.Title)
  
  for(movie_title in list_of_titles){
  table <- search_by_title(mykey,movie_title,type="movie")
  mat=rbind(mat,table)
  }
  return(mat)
}
```

You should run the function like this:

```{r 8_54_6_22_2022,eval=FALSE}
get_data_series("mykey","star_wars")
```

You should get a tibble that looks like this:

```{r example_get_data,eval=TRUE,echo=FALSE}
get_data_series("5c7f9206","star_wars")
```

# Get the Data for One or More Series

Now, lets get all of the data for both Star Wars and Indiana Jones:

```{r 9_03_6_22_2022}
mat=NULL
get_data_one_or_more_titles <- function(mykey,title){
  temp_table <- by_search_one_or_more_titles(mykey,title,type="movie")
  list_of_titles <- unique(temp_table$Search.Title)
  
  for(movie_title in list_of_titles){
  table <- search_by_title(mykey,movie_title,type="movie")
  mat=rbind(mat,table)
  }
  return(mat)
}
```

You would run the function like this:

```{r 9_05_6_22_2022,eval=FALSE}
get_data_one_or_more_titles("mykey",c("star_wars","indiana_jones"))
```


```{r test_5_11_6_20_2022,echo=FALSE}
get_data_one_or_more_titles("5c7f9206",c("star_wars","indiana_jones"))
```

# Let's make a data set!

First, I'm going to make two lists of movies:

```{r 10_04_6_22_2022}
#for these movies, I just want the first result it gives me because they are not a series:
titles <- c("casablanca",
            "the_wizard_of_oz",
            "it's_a_wonderful_life",
            "goodfellas",
            "taxi_driver",
            "psycho",
            "singin_in_the_rain",
            "2001:_a_space_odyssey",
            "vertigo")

#for these movies, I want all of them in each series:
series <- c("the_godfather",
            "star_wars",
            "alien",
            "fast_and_furious",
            "final_destination",
            "friday_the_13th")
```

Here is the function I'm going to use to get all of the data for all of my movies:

```{r 11_50_6_22_2022}
mat1=NULL
mat2=NULL
mat3=NULL
get_data_titles_and_series <- function(mykey,titles,series){
  for(i in titles){
    temp_table <- search_by_title(mykey,i,type="movie")
      mat1=rbind(mat1,temp_table)
  }
  for(j in series){
    temp_table <- by_search_series(mykey,j,type="movie")
    list_of_titles <- unique(temp_table$Search.Title)
    for(movie_title in list_of_titles){
      table2 <- search_by_title(mykey,movie_title,type="movie")
      mat2=rbind(mat2,table2)
    }
  }
  mat3=rbind(mat3,mat1,mat2)
  return(mat3)
}
```

I'm going to run the function like this:

```{r 11_51_6_22_2022,eval=FALSE}
get_data_titles_and_series("mykey",titles,series)
```

Here is the tibble I get:

```{r 11_52_6_22_2022, echo=FALSE}
get_data_titles_and_series("5c7f9206",titles,series)
```

Here is a list of the movie titles in my data set:

```{r 9_30_6_25_2022,echo=FALSE}
info <- get_data_titles_and_series("5c7f9206",titles,series)
```

```{r 9_32_6_25_2022}
length(unique(info$Title))
```

There are 61 unique titles.

```{r 9_37_6_25_2022}
unique(info$Title)
```

Great, but we can't use this data until we format it. Here's what I'm going to do in the next function:

1. Convert the following columns from character to numeric:
  + Year
  + Runtime
  + Ratings.Value
  + Metascore
  + imdbRating
  + imdbVotes
  + BoxOffice

2. Convert the values in these columns to dates (year-month-day):
  + Released
  + DVD 
  
3. Create two new columns:
  + average_rating is the average of the Ratings.Value, Metascore, and imdbRating
  + Summary_Awards shows whether a movie:
    + won and was nominated for an award
    + won an award
    + was nominated for an award
    + did not win or was not nominated for an award

Here are my helper functions: 

```{r 7_46_6_23_2022}
#this will help us convert the Ratings.Value column to numeric
parse_number <- function(S){
  if(grepl("/", S)){
    A<-str_split(S, "/")
    A<-as.numeric(unlist(A))
    A<-A[[1]]/A[[2]]
    A<-A*100
  } else {
    A<-as.numeric(gsub("%","",S))
  }
  return(A)
}

#this will help us make the Awards column more usable
award <- function(S){
  if(is.na(S)){
    A<-"none"
    return(A)
  }
  S=tolower(S)
  #won and nominated:
  if((grepl("won", S) | grepl("win", S)) && (grepl("nomina", S))){
    A<-"won and nominated"
  }
  #only won:
  else if (grepl("won", S) | grepl("win", S)){
    A<-"won"
  }
  #only nominated:
  else if (grepl("nomina", S)){
    A<-"nomination"
  }
  #no awards or nominations:
  else {(A<-"none")
     return(A)
  }
}
```

Here is my complete formatting function:

```{r 12_02_6_23_2022,message=FALSE}
mat1=NULL
format_data <- function(mykey,titles,series){
    data <- get_data_titles_and_series(mykey,titles,series)
    data$Year <- as.numeric(data$Year)
    data$Released <- dmy(data$Released)
    data$Runtime <- as.numeric(gsub(" min","",data$Runtime))
    data$Ratings.Value <- sapply(data$Ratings.Value, FUN=parse_number)
    data$Summary_Awards <- as.factor(sapply(data$Awards, FUN=award))
    data$Metascore <- as.numeric(data$Metascore)
    data$imdbRating <- as.numeric(data$imdbRating)*10
    data$imdbVotes <- as.numeric(gsub(",","",data$imdbVotes))
    data$DVD <- dmy(data$DVD)
    data$BoxOffice <- gsub("\\$","",data$BoxOffice)
    data$BoxOffice <- as.numeric(gsub(",","",data$BoxOffice))
    movie_list<-unique(data$Title)
    
    for (i in movie_list){
      temp=data[is.element(data$Title,i),]
      Ratings.Value_mean<-mean(temp$Ratings.Value)
      Metascore<-unique(temp$Metascore)
      imdbRating<-unique(temp$imdbRating)
      
      if(is.na(Metascore)==TRUE){
        temp$average_rating=(Ratings.Value_mean+imdbRating)/2
      }
      if(is.na(Metascore)==FALSE){
        temp$average_rating=(Ratings.Value_mean+Metascore+imdbRating)/3
      }
      mat1=rbind(mat1,temp)
    }
    return(mat1)
}
```

Here's how I ran it:

```{r 11_40_6_23_2022,eval=FALSE}
formatted_data<-format_data("mykey",titles,series)
```

Here's the tibble I got:

```{r 12_16_6_23_2022,echo=FALSE,warning=FALSE}
formatted_data<-format_data("5c7f9206",titles,series)
formatted_data
```

Let's find the structure of my data:

```{r 9_51_6_25_2022}
str(formatted_data)
```


# Contingency Tables

Let's say I wanted to know how many movies are rated "PG-13" in my data set. I would make a contingency table summarizing the ratings for all of the movies: 

```{r 11_45_6_23_2022}
unique_titles<-length(unique(formatted_data$Title))
unique_titles #there are 61 unique movie titles in my data set
A<-data.frame(formatted_data$Title,formatted_data$Rated)
B<-unique(A)
table(B$formatted_data.Rated)
```

As you can see, 9 out of the 61 movies from my data set are "PG-13".

Let's say I wanted to summarize how many movies fell under each genre listed. I would make the contingency table below:

```{r 11_50_6_23_2022}
C<-data.frame(formatted_data$Title,formatted_data$Genre)
D<-unique(C)
table(D$formatted_data.Genre)
```

So, for example, it looks like 7 out of the 61 from my data set are classified under the "Horror, Thriller" genre.

What if we wanted to see both the rating and the genre in the same table? We could make a two-way contingency table:

```{r 12_11_6_24_2022}
table(B$formatted_data.Rated, D$formatted_data.Genre)
```

So, for example, it looks like 5 out of the 61 movies from my data set are rated PG and fall under the "Action, Adventure, Fantasy" genre.

# Bar Plots

Let's say we wanted to find out how many movies each director made in my data set. We could make the bar graph below:

```{r 8_18_6_24_2022,fig.height = 10, fig.width = 10}
C<-data.frame(formatted_data$Title,formatted_data$Director)
D<-unique(C)
g<-ggplot(data = D, aes(x = formatted_data.Director ))
g + geom_bar() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Director", title = "Director Count", y="Number of Movies") +
  coord_flip()
```

It looks like George Lucas and Francis Ford Coppola are tied for the most number of movies.

Now, what if we wanted to see, for each director, how many movies either won or was nominated for awards. We could make the bar graph below.

```{r 10_54_6_25_2022, fig.height = 10, fig.width = 10}
C<-data.frame(formatted_data$Title,formatted_data$Director,formatted_data$Summary_Awards)
D<-unique(C)
g<-ggplot(data = D, aes(x = formatted_data.Director ))
g + geom_bar(aes(fill = as.factor(formatted_data.Summary_Awards))) +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Director", title = "Director Count", y="Number of Movies") +
  scale_fill_discrete(name = NULL) +
  coord_flip()
```

It looks like, for all 4 of George Lucas' movies, all of them won and were nominated for awards.

# Box Plot

Let's explore the imdbVotes column. First, let's find the average number of imdbVotes in our entire data set:

```{r 11_38_6_25_2022}
imdbVotes <- unique(formatted_data$imdbVotes)
avg_imdbVotes <- mean(imdbVotes)
avg_imdbVotes
```

On average, every movie in my data set gets 332324 imdbVotes. Let's make a box plot showing the spread of the number of imdbVotes for every genre:

```{r 11_40_6_25_2022}
A<-data.frame(formatted_data$Genre,formatted_data$imdbVotes)
B<-unique(A)
genre_list=unique(B$formatted_data.Genre)
length(genre_list) #there are 30 different genres
```

```{r 12_29_6_25_2022}
B %>%
  ggplot(aes(x = formatted_data.Genre, y = formatted_data.imdbVotes, fill = formatted_data.Genre)) +
  geom_boxplot() +
  theme(legend.position = "none",axis.text.x = element_text(angle = 90)) +
  labs(x = "Genre", title = "imdbVotes By Genre", y="Number of imdbVotes") +
  coord_flip()
```

It looks like genre with the most spread, or variance, is "Crime, Drama". Now, let's calculate the average number of imdbVotes for each genre:

```{r 12_28_6_25_2022}
mat1=NULL
avg_imdbVotes_by_genre <- function(){
  for (i in genre_list){
      temp=B[is.element(B$formatted_data.Genre,i),]
      temp$avg_genre<-mean(temp$formatted_data.imdbVotes)
      mat1=rbind(mat1,temp)
  }
  return(mat1)
}
result<-avg_imdbVotes_by_genre()
result<-result %>% select(formatted_data.Genre,avg_genre)
result<-unique(result)
rownames(result)<-1:30
result
```

Now, let's find the 5-number summary for this data set.

```{r 12_14_6_25_2022}
summary(result$avg_genre)
```

So, it looks like the genre with the most number of votes on average is "Biography, Crime, Drama" and the genre with the least number of votes on average is "Documentary, Short".

Now, let's see if the number of imdbVotes is related to the average rating.

```{r 2_49_6_25_2022}
A <- formatted_data %>%
  select(imdbVotes,average_rating)
B<-unique(A)
cov(B$imdbVotes,B$average_rating) #Covariance
cor(B$imdbVotes,B$average_rating) #Correlation
```

The covariance is 4539894, meaning that there is a positive linear relationship between imdbVotes and average_rating.

The correlation coefficient is 0.5827316, meaning that imdbVotes and average_rating have a positive relationship.

Let's make a histogram showing the distribution of of the "Year" column:

```{r 3_14_6_25_2022}
A <- formatted_data %>%
  select(Title,Year,Summary_Awards)
B<-unique(A)

g <- ggplot(B, aes(x = Year))
g + geom_histogram(color = "blue", fill = "red",
size = 2, binwidth = 3) +
  labs(x = "Year", title = "Distribution of Movies by Year", y="Number of Movies")
```

It looks like most of the movies in my data set were made after 1975, with a peak in the late 1980s. 

Let's smooth it out with a Kernel Smoother. 

```{r 3_27_6_25_2022,message=FALSE}
ggplot(B, aes(x = Year)) + geom_histogram(aes(y = ..density..),fill = "lightgrey") +
  geom_density(adjust = 0.25, size = 1) +
  labs(x = "Year", title = "Distribution of Movies by Year", y="Number of Movies")
```

The line helps us see that there are two peaks, one at around 1988 and one around 2006. 

Now, lets make a scatterplot:

```{r 4_07_6_25_2022,message=FALSE}
A <- formatted_data %>%
  select(BoxOffice, average_rating,Year)
A <- A %>% drop_na(BoxOffice) #removing some NAs from BoxOffice column
B<-unique(A)

correlation <- cor(B$average_rating, B$BoxOffice)

g <- ggplot(B, aes(x = average_rating, y = BoxOffice))
g + geom_text(aes(label = Year)) +
geom_smooth(method = lm, col = "Red") +
  labs(x = "Average Rating", title = "Average Rating vs. Box Office", y="Box Office") +
  geom_text(x = 40, y = 7.5e+08, size = 5, label = paste0("Correlation = ", round(correlation, 3)))
  
```

As you can see, as average_rating increases, so does BoxOffice. In addition, there was one movie made in 2015 that did quite well at the Box Office.


The next graph is:




movie title in mind, like Star Wars. Here's a function you can use to get data from the OMDb API about Star Wars:



This is my .Rmd file. Test. Test 2

```{r plot}
plot(iris)
```